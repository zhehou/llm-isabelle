// LLM_PlanFill.bsh — auto-extract goal, call /plan_fill (mode:auto), and insert the first filled script.
// BeanShell-friendly (Java 1.4 style): no generics, no enhanced for-loops.

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.util.regex.*;
import java.util.ArrayList;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;

// ------------------ Config ------------------
String SERVER_BASE = "http://127.0.0.1:5005";
String ENDPOINT = SERVER_BASE + "/plan_fill";

String MODEL = "gemini:gemini-2.5-flash";
int BUDGET = 300;          // seconds

// Planner knobs (defaults mirror server)
boolean DIVERSE = true;
int K = 3;
// String TEMPS = "[0.35,0.55,0.85]"; // optional; null → server default schedule
String TEMPS = null;

boolean REPAIRS = true;
boolean REPAIR_TRACE = false;
// --------------------------------------------

// Helpers
String jquote(String s) {
  if (s == null) return "null";
  StringBuffer b = new StringBuffer("\"");
  for (int i=0;i<s.length();i++) {
    char c = s.charAt(i);
    if (c=='\\' || c=='"') b.append('\\').append(c);
    else if (c=='\n') b.append("\\n");
    else if (c=='\r') b.append("\\r");
    else if (c=='\t') b.append("\\t");
    else b.append(c);
  }
  b.append('"');
  return b.toString();
}

String readAll(InputStream is) throws Exception {
  if (is == null) return "";
  BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
  StringBuffer sb = new StringBuffer();
  String line;
  while ((line = br.readLine()) != null) sb.append(line).append("\n");
  br.close();
  return sb.toString();
}

String extractGoalFromAroundCaret(View view, int lookAroundLines) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  int line = ta.getLineOfOffset(caret);

  Pattern qp = Pattern.compile("\"([^\"\\\\]|\\\\.)*\"");
  int last = Math.min(buf.getLineCount()-1, line + lookAroundLines);
  for (int ln = line; ln <= last; ln++) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  int first = Math.max(0, line - lookAroundLines);
  for (int ln = line-1; ln >= first; ln--) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  return null;
}

int findLineWithTokens(Buffer buf, int startLine, int maxLook, String[] tokens) {
  int end = Math.min(buf.getLineCount()-1, startLine + maxLook);
  for (int ln = startLine; ln <= end; ln++) {
    String s = buf.getLineText(ln).trim();
    for (int i=0;i<tokens.length;i++) {
      if (s.equals(tokens[i])) return ln;
    }
  }
  return -1;
}

void replaceLine(Buffer buf, int line, String text) {
  int off = buf.getLineStartOffset(line);
  int len = buf.getLineLength(line);
  buf.remove(off, len);
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(off, text);
}

void insertAtCaret(View view, String text) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(caret, text);
}

// crude JSON: extract "fills":[ ... ] into an array of strings (no generics)
String[] parseFills(String body) {
  try {
    int idx = body.indexOf("\"fills\"");
    if (idx < 0) return null;
    int lb = body.indexOf("[", idx);
    int rb = body.indexOf("]", lb);
    if (lb < 0 || rb < 0) return null;
    String arr = body.substring(lb+1, rb);

    ArrayList out = new ArrayList();
    boolean inQ = false;
    StringBuffer cur = new StringBuffer();
    for (int i=0;i<arr.length();i++) {
      char c = arr.charAt(i);
      if (c=='"' && (i==0 || arr.charAt(i-1)!='\\')) {
        inQ = !inQ;
        if (!inQ) { out.add(cur.toString()); cur.setLength(0); }
      } else if (inQ) {
        cur.append(c);
      }
    }
    String[] res = new String[out.size()];
    for (int i=0;i<out.size();i++) res[i] = (String) out.get(i);
    return res;
  } catch (Exception e) {
    return null;
  }
}

// -------------- Main flow --------------
Buffer buf = view.getBuffer();
JEditTextArea ta = view.getTextArea();
int caret = ta.getCaretPosition();
int caretLine = ta.getLineOfOffset(caret);

String goal = extractGoalFromAroundCaret(view, 6);
if (goal == null || goal.length() == 0) {
  Macros.error(view, "Could not deduce a goal (looked for quoted proposition near caret).");
  return;
}

String theoryFile = buf.getPath();
String theoryText = null;
if (theoryFile == null || theoryFile.length() == 0) {
  theoryText = buf.getText(0, buf.getLength());
}

StringBuffer sb = new StringBuffer();
sb.append("{");
sb.append("\"goal\":").append(jquote(goal));
sb.append(",\"timeout\":").append(BUDGET);
sb.append(",\"mode\":\"auto\"");
sb.append(",\"diverse\":").append(DIVERSE ? "true":"false");
sb.append(",\"k\":").append(K);
if (MODEL != null && MODEL.length()>0) sb.append(",\"model\":").append(jquote(MODEL));
if (TEMPS != null) sb.append(",\"temps\":").append(TEMPS);
sb.append(",\"repairs\":").append(REPAIRS ? "true":"false");
sb.append(",\"repair_trace\":").append(REPAIR_TRACE ? "true":"false");
if (theoryFile != null && theoryFile.length() > 0)
  sb.append(",\"theory_file\":").append(jquote(theoryFile));
else
  sb.append(",\"theory_text\":").append(jquote(theoryText));
sb.append("}");
String payload = sb.toString();

try {
  URL u = new URL(ENDPOINT);
  HttpURLConnection conn = (HttpURLConnection)u.openConnection();
  conn.setConnectTimeout(5000);
  conn.setReadTimeout(1000 * (BUDGET + 10));
  conn.setRequestMethod("POST");
  conn.setRequestProperty("Content-Type", "application/json; charset=utf-8");
  conn.setDoOutput(true);

  OutputStream os = conn.getOutputStream();
  os.write(payload.getBytes("UTF-8"));
  os.flush();
  os.close();

  int code = conn.getResponseCode();
  String body = (code >= 200 && code < 300) ? readAll(conn.getInputStream())
                                            : readAll(conn.getErrorStream());

  if (code < 200 || code >= 300) {
    Macros.error(view, "LLM PlanFill error (HTTP " + code + "):\n" + body);
    return;
  }

  String[] fills = parseFills(body);
  if (fills == null || fills.length == 0) {
    insertAtCaret(view, "(* LLM PlanFill (no fills parsed): *)\n" + body + "\n");
    Macros.message(view, "LLM PlanFill: no fills parsed; inserted raw JSON as a comment.");
    return;
  }

  String script = fills[0];
  // Prefer to replace a nearby 'sorry'
  int target = findLineWithTokens(buf, caretLine, 30, new String[] {"sorry"});
  if (target >= 0) replaceLine(buf, target, script);
  else insertAtCaret(view, script);

} catch (Exception ex) {
  Macros.error(view, "LLM PlanFill exception: " + ex);
}
