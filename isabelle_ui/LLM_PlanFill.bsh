// LLM_PlanFill.bsh — call /plan_fill, unescape JSON, and insert only the proof block (proof … qed/done).
// BeanShell-safe (no generics).

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.util.regex.*;
import java.util.ArrayList;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;

// ------------------ Config ------------------
String SERVER_BASE = "http://127.0.0.1:5005";
String ENDPOINT = SERVER_BASE + "/plan_fill";

String MODEL = "gemini:gemini-2.5-flash";
int BUDGET = 100;

boolean DIVERSE = true;
int K = 3;
// String TEMPS = "[0.35,0.55,0.85]";  // optional; null → server default
String TEMPS = null;

boolean REPAIRS = true;
boolean REPAIR_TRACE = false;
// --------------------------------------------

String jquote(String s) {
  if (s == null) return "null";
  StringBuffer b = new StringBuffer("\"");
  for (int i=0;i<s.length();i++) {
    char c = s.charAt(i);
    if (c=='\\' || c=='"') b.append('\\').append(c);
    else if (c=='\n') b.append("\\n");
    else if (c=='\r') b.append("\\r");
    else if (c=='\t') b.append("\\t");
    else b.append(c);
  }
  b.append('"');
  return b.toString();
}

String readAll(InputStream is) throws Exception {
  if (is == null) return "";
  BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
  StringBuffer sb = new StringBuffer();
  String line;
  while ((line = br.readLine()) != null) sb.append(line).append("\n");
  br.close();
  return sb.toString();
}

// -------- JSON string helpers (BeanShell-safe) --------
String jsonUnescape(String s) {
  if (s == null) return null;
  StringBuffer out = new StringBuffer();
  boolean esc = false;
  for (int i=0;i<s.length();i++) {
    char c = s.charAt(i);
    if (!esc) {
      if (c=='\\') esc = true;
      else out.append(c);
    } else {
      // handle common escapes
      if (c=='n') out.append('\n');
      else if (c=='r') out.append('\r');
      else if (c=='t') out.append('\t');
      else if (c=='\\') out.append('\\');
      else if (c=='"') out.append('"');
      else {
        // best effort: keep char as-is if unknown escape
        out.append(c);
      }
      esc = false;
    }
  }
  return out.toString();
}

// Find first quoted proposition " … " around caret (±N lines)
String extractGoalFromAroundCaret(View view, int lookAroundLines) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  int line = ta.getLineOfOffset(caret);

  Pattern qp = Pattern.compile("\"([^\"\\\\]|\\\\.)*\"");
  int last = Math.min(buf.getLineCount()-1, line + lookAroundLines);
  for (int ln = line; ln <= last; ln++) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  int first = Math.max(0, line - lookAroundLines);
  for (int ln = line-1; ln >= first; ln--) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  return null;
}

int findLineWithTokens(Buffer buf, int startLine, int maxLook, String[] tokens) {
  int end = Math.min(buf.getLineCount()-1, startLine + maxLook);
  for (int ln = startLine; ln <= end; ln++) {
    String s = buf.getLineText(ln).trim();
    for (int i=0;i<tokens.length;i++) if (s.equals(tokens[i])) return ln;
  }
  return -1;
}

void replaceLine(Buffer buf, int line, String text) {
  int off = buf.getLineStartOffset(line);
  int len = buf.getLineLength(line);
  buf.remove(off, len);
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(off, text);
}

void insertAtCaret(View view, String text) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(caret, text);
}

// ------- crude JSON parsing for fills / outline --------
String[] parseFills(String body) {
  try {
    int idx = body.indexOf("\"fills\"");
    if (idx < 0) return null;
    int lb = body.indexOf("[", idx);
    int rb = body.indexOf("]", lb);
    if (lb < 0 || rb < 0) return null;
    String arr = body.substring(lb+1, rb);

    ArrayList out = new ArrayList();
    boolean inQ = false;
    StringBuffer cur = new StringBuffer();
    for (int i=0;i<arr.length();i++) {
      char c = arr.charAt(i);
      if (c=='"' && (i==0 || arr.charAt(i-1)!='\\')) {
        inQ = !inQ;
        if (!inQ) { out.add(cur.toString()); cur.setLength(0); }
      } else if (inQ) {
        // keep backslashes; we'll unescape later
        cur.append(c);
      }
    }
    String[] res = new String[out.size()];
    for (int i=0;i<out.size();i++) res[i] = (String) out.get(i);
    return res;
  } catch (Exception e) { return null; }
}

String parseOutline(String body) {
  try {
    int i = body.indexOf("\"outline\"");
    if (i < 0) return null;
    int colon = body.indexOf(":", i);
    int firstQ = body.indexOf("\"", colon+1);
    if (firstQ < 0) return null;
    StringBuffer s = new StringBuffer();
    boolean esc = false;
    for (int j=firstQ+1; j<body.length(); j++) {
      char c = body.charAt(j);
      if (esc) { s.append('\\').append(c); esc = false; continue; } // keep escapes, unescape later
      if (c=='\\') { esc = true; continue; }
      if (c=='\"') break;
      s.append(c);
    }
    return s.toString();
  } catch (Exception e) { return null; }
}

// Extract "proof ... qed" (or "proof ... done")
String extractProofBlockOnly(String script) {
  if (script == null) return null;
  String s = script;
  int start = -1;
  for (int i=0; i+5<=s.length(); i++) {
    if (s.regionMatches(true, i, "proof", 0, 5)) {
      char prev = (i==0) ? ' ' : s.charAt(i-1);
      char next = (i+5>=s.length()) ? ' ' : s.charAt(i+5);
      boolean leftOK = Character.isWhitespace(prev) || prev=='\n';
      boolean rightOK = Character.isWhitespace(next) || next=='-' || next=='\n';
      if (leftOK && rightOK) { start = i; break; }
    }
  }
  if (start < 0) return null;

  int endQED = -1, endDONE = -1;
  for (int j=start+5; j+3<=s.length(); j++) {
    if (s.regionMatches(true, j, "qed", 0, 3)) {
      char prev = (j==0) ? ' ' : s.charAt(j-1);
      char next = (j+3>=s.length()) ? '\n' : s.charAt(j+3);
      boolean leftOK = Character.isWhitespace(prev) || prev=='\n';
      boolean rightOK = (j+3==s.length()) || Character.isWhitespace(next) || next=='\n';
      if (leftOK && rightOK) { endQED = j+3; break; }
    }
  }
  if (endQED < 0) {
    for (int j=start+5; j+4<=s.length(); j++) {
      if (s.regionMatches(true, j, "done", 0, 4)) {
        char prev = (j==0) ? ' ' : s.charAt(j-1);
        char next = (j+4>=s.length()) ? '\n' : s.charAt(j+4);
        boolean leftOK = Character.isWhitespace(prev) || prev=='\n';
        boolean rightOK = (j+4==s.length()) || Character.isWhitespace(next) || next=='\n';
        if (leftOK && rightOK) { endDONE = j+4; break; }
      }
    }
  }

  int end = (endQED >= 0) ? endQED : endDONE;
  if (end < 0) return s.substring(start).trim();
  return s.substring(start, end).trim();
}

// -------------- Main flow --------------
Buffer buf = view.getBuffer();
JEditTextArea ta = view.getTextArea();
int caret = ta.getCaretPosition();
int caretLine = ta.getLineOfOffset(caret);

String goal = extractGoalFromAroundCaret(view, 6);
if (goal == null || goal.length() == 0) {
  Macros.error(view, "Could not deduce a goal (looked for quoted proposition near caret).");
  return;
}

String theoryFile = buf.getPath();
String theoryText = null;
if (theoryFile == null || theoryFile.length() == 0) {
  theoryText = buf.getText(0, buf.getLength());
}

StringBuffer sb = new StringBuffer();
sb.append("{");
sb.append("\"goal\":").append(jquote(goal));
sb.append(",\"timeout\":").append(BUDGET);
sb.append(",\"mode\":\"auto\"");
sb.append(",\"diverse\":").append(DIVERSE ? "true":"false");
sb.append(",\"k\":").append(K);
if (MODEL != null && MODEL.length()>0) sb.append(",\"model\":").append(jquote(MODEL));
if (TEMPS != null) sb.append(",\"temps\":").append(TEMPS);
sb.append(",\"repairs\":").append(REPAIRS ? "true":"false");
sb.append(",\"repair_trace\":").append(REPAIR_TRACE ? "true":"false");
if (theoryFile != null && theoryFile.length() > 0)
  sb.append(",\"theory_file\":").append(jquote(theoryFile));
else
  sb.append(",\"theory_text\":").append(jquote(theoryText));
sb.append("}");
String payload = sb.toString();

try {
  URL u = new URL(ENDPOINT);
  HttpURLConnection conn = (HttpURLConnection)u.openConnection();
  conn.setConnectTimeout(5000);
  conn.setReadTimeout(1000 * (BUDGET + 10));
  conn.setRequestMethod("POST");
  conn.setRequestProperty("Content-Type", "application/json; charset=utf-8");
  conn.setDoOutput(true);

  OutputStream os = conn.getOutputStream();
  os.write(payload.getBytes("UTF-8"));
  os.flush();
  os.close();

  int code = conn.getResponseCode();
  String body = (code >= 200 && code < 300) ? readAll(conn.getInputStream())
                                            : readAll(conn.getErrorStream());

  if (code < 200 || code >= 300) {
    Macros.error(view, "LLM PlanFill error (HTTP " + code + "):\n" + body);
    return;
  }

  String script = null;
  String[] fills = parseFills(body);
  if (fills != null && fills.length > 0) script = fills[0];
  if (script == null || script.trim().length()==0) script = parseOutline(body);

  if (script == null || script.trim().length()==0) {
    insertAtCaret(view, "(* LLM PlanFill (no script parsed): *)\n" + body + "\n");
    Macros.message(view, "LLM PlanFill: no script parsed; inserted raw JSON.");
    return;
  }

  script = jsonUnescape(script);                 // <<< fix \n etc.
  String proofOnly = extractProofBlockOnly(script);
  if (proofOnly == null || proofOnly.trim().length()==0) proofOnly = script;

  int target = findLineWithTokens(buf, caretLine, 30, new String[] {"sorry"});
  if (target >= 0) replaceLine(buf, target, proofOnly);
  else insertAtCaret(view, proofOnly);

} catch (Exception ex) {
  Macros.error(view, "LLM PlanFill exception: " + ex);
}
