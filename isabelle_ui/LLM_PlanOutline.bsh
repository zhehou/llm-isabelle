// LLM_PlanOutline.bsh â€” auto-extract goal, call /plan_fill in outline mode,
// and insert the outline (replacing nearby 'sorry' if present).
// BeanShell-friendly (Java 1.4 style).

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.util.regex.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;

// ------------------ Config ------------------
String SERVER_BASE = "http://127.0.0.1:5005";
String ENDPOINT = SERVER_BASE + "/plan_fill";

String MODEL = "gemini:gemini-2.5-flash";
int BUDGET = 200;

// For a single clean outline:
boolean DIVERSE = false;
int K = 1;
// --------------------------------------------

String jquote(String s) {
  if (s == null) return "null";
  StringBuffer b = new StringBuffer("\"");
  for (int i=0;i<s.length();i++) {
    char c = s.charAt(i);
    if (c=='\\' || c=='"') b.append('\\').append(c);
    else if (c=='\n') b.append("\\n");
    else if (c=='\r') b.append("\\r");
    else if (c=='\t') b.append("\\t");
    else b.append(c);
  }
  b.append('"');
  return b.toString();
}

String readAll(InputStream is) throws Exception {
  if (is == null) return "";
  BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
  StringBuffer sb = new StringBuffer();
  String line;
  while ((line = br.readLine()) != null) sb.append(line).append("\n");
  br.close();
  return sb.toString();
}

String extractGoalFromAroundCaret(View view, int lookAroundLines) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  int line = ta.getLineOfOffset(caret);

  Pattern qp = Pattern.compile("\"([^\"\\\\]|\\\\.)*\"");
  int last = Math.min(buf.getLineCount()-1, line + lookAroundLines);
  for (int ln = line; ln <= last; ln++) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  int first = Math.max(0, line - lookAroundLines);
  for (int ln = line-1; ln >= first; ln--) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  return null;
}

int findLineWithTokens(Buffer buf, int startLine, int maxLook, String[] tokens) {
  int end = Math.min(buf.getLineCount()-1, startLine + maxLook);
  for (int ln = startLine; ln <= end; ln++) {
    String s = buf.getLineText(ln).trim();
    for (int i=0;i<tokens.length;i++) {
      if (s.equals(tokens[i])) return ln;
    }
  }
  return -1;
}

void replaceLine(Buffer buf, int line, String text) {
  int off = buf.getLineStartOffset(line);
  int len = buf.getLineLength(line);
  buf.remove(off, len);
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(off, text);
}

void insertAtCaret(View view, String text) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(caret, text);
}

// extract "outline":" ... " from JSON string (crude)
String parseOutline(String body) {
  try {
    int i = body.indexOf("\"outline\"");
    if (i < 0) return null;
    int colon = body.indexOf(":", i);
    int firstQ = body.indexOf("\"", colon+1);
    if (firstQ < 0) return null;
    StringBuffer s = new StringBuffer();
    boolean esc = false;
    for (int j=firstQ+1; j<body.length(); j++) {
      char c = body.charAt(j);
      if (esc) { s.append(c); esc = false; continue; }
      if (c=='\\') { esc = true; continue; }
      if (c=='\"') break;
      s.append(c);
    }
    return s.toString();
  } catch (Exception e) {
    return null;
  }
}

// -------------- Main flow --------------
Buffer buf = view.getBuffer();
JEditTextArea ta = view.getTextArea();
int caret = ta.getCaretPosition();
int caretLine = ta.getLineOfOffset(caret);

String goal = extractGoalFromAroundCaret(view, 6);
if (goal == null || goal.length() == 0) {
  Macros.error(view, "Could not deduce a goal (looked for quoted proposition near caret).");
  return;
}

String theoryFile = buf.getPath();
String theoryText = null;
if (theoryFile == null || theoryFile.length() == 0) {
  theoryText = buf.getText(0, buf.getLength());
}

StringBuffer sb = new StringBuffer();
sb.append("{");
sb.append("\"goal\":").append(jquote(goal));
sb.append(",\"timeout\":").append(BUDGET);
sb.append(",\"mode\":\"outline\"");
sb.append(",\"diverse\":").append(DIVERSE ? "true":"false");
sb.append(",\"k\":").append(K);
if (MODEL != null && MODEL.length()>0) sb.append(",\"model\":").append(jquote(MODEL));
if (theoryFile != null && theoryFile.length() > 0)
  sb.append(",\"theory_file\":").append(jquote(theoryFile));
else
  sb.append(",\"theory_text\":").append(jquote(theoryText));
sb.append("}");
String payload = sb.toString();

try {
  URL u = new URL(ENDPOINT);
  HttpURLConnection conn = (HttpURLConnection)u.openConnection();
  conn.setConnectTimeout(5000);
  conn.setReadTimeout(1000 * (BUDGET + 10));
  conn.setRequestMethod("POST");
  conn.setRequestProperty("Content-Type", "application/json; charset=utf-8");
  conn.setDoOutput(true);

  OutputStream os = conn.getOutputStream();
  os.write(payload.getBytes("UTF-8"));
  os.flush();
  os.close();

  int code = conn.getResponseCode();
  String body = (code >= 200 && code < 300) ? readAll(conn.getInputStream())
                                            : readAll(conn.getErrorStream());

  if (code < 200 || code >= 300) {
    Macros.error(view, "LLM PlanOutline error (HTTP " + code + "):\n" + body);
    return;
  }

  String outline = parseOutline(body);
  if (outline == null || outline.trim().length() == 0) {
    insertAtCaret(view, "(* LLM PlanOutline (no outline parsed): *)\n" + body + "\n");
    Macros.message(view, "LLM PlanOutline: no outline parsed; inserted raw JSON as a comment.");
    return;
  }

  int target = findLineWithTokens(buf, caretLine, 30, new String[] {"sorry"});
  if (target >= 0) replaceLine(buf, target, outline);
  else insertAtCaret(view, outline);

} catch (Exception ex) {
  Macros.error(view, "LLM PlanOutline exception: " + ex);
}
