// LLM_PlanOutline.bsh — Force outline; paste after caret if inside lemma; else below lemma.
// Menu: Macros → LLM_Prover → LLM_PlanOutline

import org.gjt.sp.jedit.*;
import javax.swing.JOptionPane;
import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.util.regex.*;

String SERVER = "http://127.0.0.1:5005/plan_fill";
int    BUDGET = 120;
String MODEL  = "gemini:gemini-3-flash-preview";  // optional

// --- SAFE SLICE GUARD: prevent ArrayIndexOutOfBounds in getText ---
int clampInt(int x, int lo, int hi) {
    if (x < lo) return lo;
    if (x > hi) return hi;
    return x;
}

String getTextSafe(JEditBuffer buffer, int startOffset, int endOffset) {
    // If next-boundary wasn't found, endOffset might be -1; use doc end.
    int docLen = buffer.getLength();
    int start = clampInt(startOffset, 0, docLen);
    int end   = (endOffset < 0) ? docLen : clampInt(endOffset, 0, docLen);
    if (end < start) { int t = start; start = end; end = t; }
    int len = end - start;
    if (len <= 0) return "";
    return buffer.getText(start, len);
}

Object[] findPrevLemma(Buffer buf, JEditTextArea ta) {
  Pattern pat = Pattern.compile("^\\s*(lemma|theorem)\\s+\"([^\"]+)\"", Pattern.MULTILINE);
  int caretLine = ta.getCaretLine();
  int minLine = Math.max(0, caretLine - 1000);
  for (int li = caretLine; li >= minLine; li--) {
    int ls = ta.getLineStartOffset(li);
    int le = ta.getLineEndOffset(li);
    String L = getTextSafe(buf, ls, le);
    Matcher m = pat.matcher(L);
    if (m.find()) {
      int insertPos = le - 1;
      String goal = m.group(2);
      return new Object[] { new Integer(li), new Integer(insertPos), goal };
    }
  }
  return null;
}

int findNextLemmaLine(Buffer buf, JEditTextArea ta, int fromLine) {
  Pattern pat = Pattern.compile("^\\s*(lemma|theorem)\\s+\"([^\"]+)\"", Pattern.MULTILINE);
  int total = ta.getLineCount();
  int maxLine = Math.min(total - 1, fromLine + 1000);
  for (int li = fromLine + 1; li <= maxLine; li++) {
    int ls = ta.getLineStartOffset(li);
    int le = ta.getLineEndOffset(li);
    String L = getTextSafe(buf, ls, le);
    Matcher m = pat.matcher(L);
    if (m.find()) return li;
  }
  return -1;
}

String jsonEsc(String s) { return s.replace("\\","\\\\").replace("\"","\\\""); }

String stripLeadingHeadersAndToProof(String s) {
  if (s == null) return "";
  String out = s.trim();
  // Drop any leading 'lemma ...' or 'theorem ...' lines (possibly multiple)
  // and any blank lines immediately after them.
  String[] lines = out.split("\\r?\\n");
  StringBuilder sb = new StringBuilder();
  boolean dropping = true;
  for (int i = 0; i < lines.length; i++) {
    String L = lines[i];
    String Lt = L.trim();
    if (dropping) {
      if (Lt.matches("^(lemma|theorem)\\b.*")) {
        continue; // skip header
      }
      if (Lt.isEmpty()) {
        continue; // skip leading blanks following header
      }
      dropping = false;
    }
    sb.append(L).append("\n");
  }
  out = sb.toString().trim();

  // If there is a 'proof' later, keep from the first 'proof' to the end.
  // (Models sometimes emit an extra header or text before the actual proof.)
  // We search at line starts to avoid matching words like 'proofs'.
  java.util.regex.Pattern proofPat = java.util.regex.Pattern.compile("(?m)^\\s*proof\\b");
  java.util.regex.Matcher pm = proofPat.matcher(out);
  if (pm.find()) {
    out = out.substring(pm.start()).trim();
  }
  return out;
}

String parseOutline(String resp) {
  String marker = "\"outline\":\"";
  int pos = resp.indexOf(marker);
  if (pos < 0) return null;
  int i = pos + marker.length();
  StringBuilder raw = new StringBuilder();
  boolean esc = false;
  for (; i < resp.length(); i++) {
    char c = resp.charAt(i);
    if (esc) { raw.append('\\').append(c); esc=false; continue; }
    if (c=='\\') { esc=true; continue; }
    if (c=='"') break;
    raw.append(c);
  }
  String s = raw.toString();
  StringBuilder out = new StringBuilder();
  boolean e=false;
  for (int k=0;k<s.length();k++){
    char c=s.charAt(k);
    if (e) {
      if (c=='n') out.append('\n');
      else if (c=='t') out.append('\t');
      else if (c=='r') out.append('\r');
      else if (c=='b') out.append('\b');
      else if (c=='f') out.append('\f');
      else if (c=='\\') out.append('\\');
      else if (c=='"') out.append('"');
      else out.append(c);
      e=false;
    } else if (c=='\\') { e=true; }
    else { out.append(c); }
  }
  return out.toString();
}

EditPane ep = view.getEditPane();
JEditTextArea ta = ep.getTextArea();
Buffer buf = ta.getBuffer();

Object[] anchor = findPrevLemma(buf, ta);
if (anchor == null) {
  JOptionPane.showMessageDialog(view, "Put the caret near or within a lemma/theorem.", "LLM PlanOutline", JOptionPane.WARNING_MESSAGE);
  return;
}
int lemmaLine      = ((Integer)anchor[0]).intValue();
int afterLemmaPos  = ((Integer)anchor[1]).intValue();
String goal        = (String) anchor[2];

// Inside or not?
int caretLine      = ta.getCaretLine();
int nextLemmaLine  = findNextLemmaLine(buf, ta, lemmaLine);
boolean caretInsideLemma = (caretLine > lemmaLine) && ((nextLemmaLine == -1) || (caretLine < nextLemmaLine));

int insertPos = caretInsideLemma ? (ta.getLineEndOffset(caretLine) - 1) : afterLemmaPos;

// Payload: force outline
String payload = "{"
  + "\"goal\":\"" + jsonEsc(goal) + "\","
  + "\"timeout\":" + BUDGET + ","
  + "\"mode\":\"outline\""
  + (MODEL.length()>0 ? ",\"model\":\"" + jsonEsc(MODEL) + "\"" : "")
  + "}";

// POST
HttpURLConnection conn = null;
InputStream is = null;
String resp = "";
try {
  URL url = new URL(SERVER);
  conn = (HttpURLConnection) url.openConnection();
  conn.setRequestMethod("POST");
  conn.setDoOutput(true);
  conn.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
  OutputStream os = conn.getOutputStream();
  os.write(payload.getBytes("UTF-8"));
  os.flush(); os.close();
  int code = conn.getResponseCode();
  is = (code >= 200 && code < 300) ? conn.getInputStream() : conn.getErrorStream();
  BufferedReader br = new BufferedReader(new InputStreamReader(is, Charset.forName("UTF-8")));
  StringBuilder sb = new StringBuilder(); String line;
  while ((line = br.readLine()) != null) sb.append(line);
  br.close();
  resp = sb.toString();
} catch (Exception e) {
  JOptionPane.showMessageDialog(view, "HTTP error:\n" + e, "LLM PlanOutline", JOptionPane.ERROR_MESSAGE);
  return;
} finally {
  try { if (is != null) is.close(); } catch (Exception _e) {}
  try { if (conn != null) conn.disconnect(); } catch (Exception _e) {}
}

// Parse outline
String outline = parseOutline(resp);
if (outline == null) {
  JOptionPane.showMessageDialog(view, "No outline in response:\n" + resp, "LLM PlanOutline", JOptionPane.INFORMATION_MESSAGE);
  return;
}

// Strip duplicate lemma header if present
outline = stripLeadingHeadersAndToProof(outline);

// Insert: always start on a new line
ta.selectNone();
ta.setCaretPosition(insertPos);
ta.setSelectedText("\n" + outline + (outline.endsWith("\n") ? "" : "\n"));