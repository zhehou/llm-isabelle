// LLM_Prove.bsh — auto-extract goal near caret, call /prove, insert proof at caret.
// BeanShell-friendly (no generics), Java 1.4 style.

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.util.regex.*;
import java.util.ArrayList;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;

// ------------------ Config ------------------
String SERVER_BASE = "http://127.0.0.1:5005";
String ENDPOINT = SERVER_BASE + "/prove";
String MODEL = "gemini:gemini-2.5-flash";
int BUDGET = 60;  // seconds
// --------------------------------------------

// Helpers
String jquote(String s) {
  if (s == null) return "null";
  StringBuffer b = new StringBuffer("\"");
  for (int i=0;i<s.length();i++) {
    char c = s.charAt(i);
    if (c=='\\' || c=='"') b.append('\\').append(c);
    else if (c=='\n') b.append("\\n");
    else if (c=='\r') b.append("\\r");
    else if (c=='\t') b.append("\\t");
    else b.append(c);
  }
  b.append('"');
  return b.toString();
}

String readAll(InputStream is) throws Exception {
  if (is == null) return "";
  BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
  StringBuffer sb = new StringBuffer();
  String line;
  while ((line = br.readLine()) != null) { sb.append(line).append("\n"); }
  br.close();
  return sb.toString();
}

// Find first quoted proposition " … " around caret (±N lines)
String extractGoalFromAroundCaret(View view, int lookAroundLines) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  int line = ta.getLineOfOffset(caret);

  Pattern qp = Pattern.compile("\"([^\"\\\\]|\\\\.)*\"");
  // forward
  int last = Math.min(buf.getLineCount()-1, line + lookAroundLines);
  for (int ln = line; ln <= last; ln++) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  // backward
  int first = Math.max(0, line - lookAroundLines);
  for (int ln = line-1; ln >= first; ln--) {
    String s = buf.getLineText(ln);
    java.util.regex.Matcher m = qp.matcher(s);
    if (m.find()) return s.substring(m.start()+1, m.end()-1).trim();
  }
  return null;
}

void insertAtCaret(View view, String text) {
  Buffer buf = view.getBuffer();
  JEditTextArea ta = view.getTextArea();
  int caret = ta.getCaretPosition();
  if (!text.endsWith("\n")) text = text + "\n";
  buf.insert(caret, text);
}

// Parse steps from JSON without generics (very crude, but works for flat arrays)
String[] parseStepsOrFallback(String body) {
  try {
    int idx = body.indexOf("\"steps\"");
    if (idx < 0) return null;
    int lb = body.indexOf("[", idx);
    int rb = body.indexOf("]", lb);
    if (lb < 0 || rb < 0) return null;
    String arr = body.substring(lb+1, rb);

    ArrayList out = new ArrayList();
    boolean inQ = false;
    StringBuffer cur = new StringBuffer();
    for (int i=0;i<arr.length();i++) {
      char c = arr.charAt(i);
      if (c=='"' && (i==0 || arr.charAt(i-1)!='\\')) {
        inQ = !inQ;
        if (!inQ) { out.add(cur.toString()); cur.setLength(0); }
      } else if (inQ) {
        cur.append(c);
      }
    }
    String[] res = new String[out.size()];
    for (int i=0;i<out.size();i++) res[i] = (String) out.get(i);
    return res;
  } catch (Exception ex) {
    return null;
  }
}

// -------------------- Main --------------------
Buffer buf = view.getBuffer();
JEditTextArea ta = view.getTextArea();

String sel = ta.getSelectedText();
String goal = null;
if (sel != null && sel.trim().length() > 0) goal = sel.trim();
else goal = extractGoalFromAroundCaret(view, 6);

if (goal == null || goal.length() == 0) {
  Macros.error(view, "Could not deduce a goal.\nPlace caret near: lemma \"…\" or select the proposition.");
  return;
}

String theoryFile = buf.getPath();
String theoryText = null;
if (theoryFile == null || theoryFile.length() == 0) {
  theoryText = buf.getText(0, buf.getLength());
}

StringBuffer sb = new StringBuffer();
sb.append("{");
sb.append("\"goal\":").append(jquote(goal));
sb.append(",\"timeout\":").append(BUDGET);
if (MODEL != null && MODEL.length() > 0) sb.append(",\"model\":").append(jquote(MODEL));
// context for auto context-files:
if (theoryFile != null && theoryFile.length() > 0)
  sb.append(",\"theory_file\":").append(jquote(theoryFile));
else
  sb.append(",\"theory_text\":").append(jquote(theoryText));
sb.append("}");
String payload = sb.toString();

try {
  URL u = new URL(ENDPOINT);
  HttpURLConnection conn = (HttpURLConnection)u.openConnection();
  conn.setConnectTimeout(5000);
  conn.setReadTimeout(1000 * (BUDGET + 10));
  conn.setRequestMethod("POST");
  conn.setRequestProperty("Content-Type", "application/json; charset=utf-8");
  conn.setDoOutput(true);

  OutputStream os = conn.getOutputStream();
  os.write(payload.getBytes("UTF-8"));
  os.flush();
  os.close();

  int code = conn.getResponseCode();
  String body = (code >= 200 && code < 300) ? readAll(conn.getInputStream())
                                            : readAll(conn.getErrorStream());
  if (code < 200 || code >= 300) {
    Macros.error(view, "LLM Prove error (HTTP " + code + "):\n" + body);
    return;
  }

  String[] steps = parseStepsOrFallback(body);
  if (steps == null || steps.length == 0) {
    insertAtCaret(view, "(* LLM Prove (no steps parsed): *)\n" + body + "\n");
    Macros.message(view, "LLM Prove: no steps parsed; inserted raw JSON as a comment.");
    return;
  }

  // Prefer a single "by ..." line
  String byLine = null;
  for (int i=0;i<steps.length;i++) {
    String s = steps[i].trim();
    if (s.startsWith("by ")) { byLine = s; break; }
  }

  if (byLine != null) {
    insertAtCaret(view, byLine);
  } else {
    StringBuffer ins = new StringBuffer();
    ins.append("proof -\n");
    for (int i=0;i<steps.length;i++) {
      String s = steps[i].trim();
      if (!s.startsWith("apply") && !s.startsWith("by ")) s = "apply (" + s + ")";
      ins.append("  ").append(s).append("\n");
    }
    ins.append("  done");
    insertAtCaret(view, ins.toString());
  }

} catch (Exception ex) {
  Macros.error(view, "LLM Prove exception: " + ex);
}
